# On the implementation of Atoms

## Preface

The below note was written as part of a project to measure atom occurrency in Elixir source code and general
identifier usage in Rust source code. The top fifty projects for each language were downloaded via git and scanned
programmatically. The data was suggestive that names could be compressed quite well, but also indicated that
100 projects was not a large enough sample of the ecosystem. It may be feasible to generate a generally usable short
word list for usage as atoms in very constrained environments. Some time was invested in setting up the cloud
infrastructure to scan all crates in the Rust eco-system - but the search for the perfect atom is derailing
getting the rest of this crate functional. (Also: do we really need atoms, why not just Enums?)

A usable implementation of Atom has been created with a simple encoding and will be improved from the current
state with ideas formed during the below exploration.


## On the implementation of Atoms

Generally symbolic atoms are implemented by maintaining a map from string -> integer id, known as string
interning. The integer id is used for storage and comparison of atoms, while the string -> id map is consulted
when conversion for construction or display of the atom is required.

The important feature is that once an atom is constructed, its underlying value is stable and unique for the
lifetime of the program.

A first attempt in implementing Atoms in Rust runs into a difficulty with maintaining that atom table during
compilation.  Ideally, Atoms would be implemented as a const-item in Rust, to allow the compiler to replace
all the details of the implementation with a single, compile-time calculated integer.  However, the atom table
must be mutable during compilation (to intern more atoms), but a static mutable collection isn't usable from
a const function.

A workaround was found by requiring Atoms to be defined up-front, and used by referring to a constant item
generated as part of the definition, via a declaritive macro.  Rather than maintain an Atom table, a reference
to the fully-qualified name of the constant item is stored within the atom.  Since this name is generated by
the macro during compile time it is static and does not change.  References to this string are stable and
atoms are able to be compared by comparing the reference - if two atom's point to the same string name, then
they must be the same atom.

But this workaround has several drawbacks:

 - an atom needs to be defined before it is used
 - a string name needs to be stored for every atom in the program image, even if that name is never displayed
 - using an atom requires recalling where it is defined so that it can be imported
 - atoms defined in different modules are different atoms

To eliminate these drawbacks would require the implementation of a const function or macro which provides a
one-to-one mapping between atom name and integer id at compile time. This implementation could either store
state, or remain state free.

For the stateful option, this would need to be implemented as a procedural macro (because const functions
can not mutate state). However, in the face of incremental compilation, the macro is not guaranteed to be run
for all invocations on every build.  That is, if a source file hasn't changed, rustc may determine the cached
output of a previous compilation is reusable and the atoms defined in that cached output would not trigger
a call to macro.  Thus a simple counter based approach is not workable if the state is maintained only during
a run of the compiler.

To properly implement the stateful option, the string intern table would need to be stored on the filesystem,
in the crate's `target` directory so that atom id's used in previous builds are not reused for different atoms
in subsequent builds. This insures that all atom ids are unique in the crate, and worst case wastes some ids
which had been used in the past but are no longer present.  On even a 32-bit system, 4 billion ids would be
available and running out seems unlikely. Running `cargo clean` would delete the incremental compilation cache
as well as the atom table - which means that atom id's would differ on the next build. This could be ok, as long
as the program never relied on Atoms to be stable outside of the binary - e.g. by sending them over the network
or storing them in a file.

What about the stateless option? Let's first restrict the allowable character set of atoms to be lowercase
alphanumeric ascii, where the first character must be a letter or underscore and subsequent characters may
be a letter, digit, or underscore. That is 27 possibilities for the first character and 37 possibilities for
the subsequent characters. The first character requires log_2(27) => 4.75 bits to store and subsequent characters
require log_2(37) => 5.21 bits. The length of the atom name is limited by the size of the integer in this
scheme:
 
| Integer Size | Atom Name Length |
+--------------+------------------+
|    32-bit    | 5 characters     |
|    64-bit    | 11 characters    |
|   128-bit    | 23 characters    |

Limited to 32-bit integers, a 5 character atom name limit would feel rather constrained. However, 11 characters
at 64-bits could provide enough room to not be a serious limitation given the benefits.

In the stateless case, atoms do not require definition before use. Nor do they require a macro to implement
as all calculations done against the atom name to find the id can be handled in a const function. Additionally,
the atoms are stable and can be stored or sent over the network.

Could we do better? In the simplest encoding, all potential atom names are given the same weight. e.g. the atom
"start" is just as likely to be encoded as "h27yg".  But this isn't how we program - some identifiers would
be expected to be very common, such as "ok", and random strings much less likely. This implies that compression
could be of benefit - but to implement compression requires information on the frequency of use of likely
atom identifier so that fewer bits are used to encode more likely names.

To explore the feasibility of using compression for atom names, this project extracts atom names from a
collection of the most popular Elixir packages to generate the data used for name compression in the atom function.
